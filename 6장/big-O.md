# big-O
big-O는 알고리즘의 효율성을 나타내는 지표 혹은 언어이다
## 비유하기
- 파일이 작을경우 온라인을 통한 전송이 당연히 빠를것이다
- 하지만 파일 용량이 무지막지하게 클 경우, 직접 목적지로 가져가는게 빠를 수 있다
## 시간 복잡도
- 온라인 전송: O(n)
- 비행기를 통한 전송: O(1)
### 최선의 경우, 최악의경우, 평균적인 경우
퀵정렬(quick sort)의 관점으로 비교
- 최선의 경우 O(n): 모든 원소가 동일하다면 단순히 배열을 한차례 순회하고 끝날것이다.
- 최악의 경우 O(N^2): 배열이 역순이고, 첫번째원소를 항상 피봇으로 잡는다면
- 평균적인 경우 O(NlogN): 최선과 최악의 경우는 잘 일어나지 않음
## 공간 복잡도
알고리즘에서는 시간뿐 아니라 메모리 또한 신경써야함

시간복잡도와는 평생선을 달리는 개념
- n개의 1차원 배열: O(N)
- n개의 2차원 배열: O(N^2)
스택 또한 공간복잡도 계산에 포함
```java
int sum(int n) {
    if (n <= 0) {
        return 0;
    }
    return n + sum(n-1);
}

sum(4)
  -> sum(3)
    -> sum(2)
      -> sum(1)
        -> sum(0)
```
단지 n번 호출됐다고 해서 O(N) 공간을 사용한다고 말할 수 없다.
```java
int pairSumSequence(int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += pairSum(i, i + 1);
    }
    return sum;
}

int pairSum(int a, int b) {
    return a + b;
}
```
함수는 n번 호출됐지만 스택에는 동시에 존재하지 않으므로 O(1)

## 상수항은 무시하라
```java
// 최소와 최대 1
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int x : array) {
    if (x < min) min = x;
    if (x > max) max = x;
}
// 최소와 최대 2
int min = Integer.MAX_VALUE;
int max = Integer.MIN_VALUE;
for (int x : array) {
    if (x < min) min = x;
}
for (int x : array) {
    if (x > max) max = x;
}
```
둘 중 어느것이 더 효율적이라고 보는가?

어셈블리 단계 컴파일러 최적화등 세부사항을 하나하나 따져야함.

분석할 생각조차 하지 말것.

결론은 둘다 O(N) 이다.

## 지배적이지 않은 항은 무시하라
수식에서 차수가 낮은 항은 무시해도 된다.
```
O(N^2 + N) => O(N^2)
O(N + logN) => O(N)
O(5*2^N + 1000N^100) => O(2^N)
```

크기 비교
```
O(N!) > O(2^N) > O(N^2) > O(NlogN) > O(N) > O(logN) > O(1)
```
## 여러 부분으로 이루어진 알고리즘: 덧셈 vs 곱셈
덧셈 수행 시간: O(A+B)
```java
for (int a : arrA) {
    print(a);
}
for (int b : arrB) {
    print(b);
}
```

곱셈 수행 시간: O(A*B)

```java
for (int a : arrA) {
    for (int b : arrB) {
        print(a + "," + b);
    }
}
```

## 상환 시간
상환 시간: 최악의 경우는 가끔 발생하지만 한번발생하면 그후로 꽤 오랫동안 나타나지 않으므로 비용(수행 시간)을 분할상환 한다는 개념

```
ArrayList(동적 가변크기 배열)은 배열의 역할을 함과 동시에 크기가 자유롭게 조절되는 자료구조이다.

새로운 원소를 넣는경우 시간 복잡도
1. 가용공간이 있는 경우
    - 시간복잡도는 O(1)
2. 배열이 가득차 있을때
    - 시간복잡도는 O(N)
    - 새로운 배열을 만들고 값을 복사 하기 때문

배열의 크기가 2의 승수가 되었을 때 원소를 삽입하면 용량이 두배로 증가한다.
- 1, 2, 4, 8, 16, ..., X

합을 구하면
- 1 + 2 + 4 + 8 + 16 + ... + X

반대로 읽으면
- X + X/2 + X/4 + X/8 + X/16 + ... + 1 = 2X

결론
- X개의 원소를 삽입 했을때 필요한 시간은 O(2X)
- 삽입 한번에 필요한 시간은 O(1)
```

## log N 수행시간
이진 탐색(binary search)을 생각해보자.

N개의 배열에서 원소의 개수가 N/2가 줄고, 한단계가 더 지나면 N/4개로 줄어든다. 그러다가 원소가 하나가 남으면 탐색을 중지한다.

```
N = 16
N = 8
N = 4
N = 2
N = 1
```
순서를 뒤집이서 생각해보자
```
N = 1
N = 2
N = 4
N = 8
N = 16
```
즉 2^k = N을 만족하는 k는 무엇인가?

```
2^4 = 16 -> log2 16 = 4
log2 N = k -> 2^k = N
```

결론적으로 수행시간은 O(logN) 이다.

또한, big-O에서는 로그의 밑을 고려할 필요가 없다고 보면 된다.

## 재귀적으로 수행시간 구하기
이 피보나치 수열을 보자.

```java
int f(int n) {
    if (n <= 1) {
        return 1;
    }
    return f(n - 1) + f(n - 1);
}
```
함수 f가 두번 호출된것을 보고 O(N^2)이라고 결론내리면 완전 틀린것.

호출이 한단계 깊어질 때 마다, 이전보다 두배 더 많이 호출하게 된다.

깊이|노드의 개수|다른 표현방식|또 다른 표현방식
-|-|-|-
0|1| |2^0
1|2|2 * 1|2^1
2|4|2 * 2|2^2
3|8|2 * 4|2^3
4|16|2 * 8|2^4

전체 노드의 개수
```
2^0 + 2^1 + 2^2 + 2^3 + ... + 2^N
  => 2^(N+1) - 1
```
결론
```
O(2^N)
```

big-O에서 지수의 밑은 무시하면 안된다
```
8^n => (2^3)^n => 2^3n => 2^2n*2^n
```

