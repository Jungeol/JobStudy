# 기술적 문제
기술적문제는 어렵지만, 사실 논리적 방법이 존재한다
## 준비하기
1. 직접 풀어보도록 노력하라
    - 포기하지말고 꼭 직접 풀기
    - 공간과 시간 효율에 대해 생각하기
2. 코드를 종이에 적으라
    - 언제나 IDE를 사용할수 있는건 아니다
3. 코드를 테스트 하라
    - 일반적인 경우 뿐 아니라, 기본 조건, 오류 발생 조건 등을 전부 테스트 해야한다.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라
    - 실수 목록을 만들고 면접에서는 같은 실수를 저지르지 않도록 유의하라

가상 면접을 가능한 많이 해보길 바람

## 알고있어야 할 것들
### 핵심 자료구조, 알고리즘, 기본개념
대부분의 면접관은 이진 트리의 균형을 맞추는 특정 방법이나 기타 복잡한 알고리즘에 대한 질문을 하지 않는다.
여러분에게 기대하는건 기본기다. 반드시 알아야 할것은 아래와 같다.

|자료구조|알고리즘|개념|
|-|-|-|
|연결리스트(Linked List)|너비 우선 탐색(Breadth-First Search)|비트 조작(Bit Manipulaion)|
|트리,트라이(Tries),그래프|깊이 우선 탐색(Depth-First Search)|메모리(스택vs힙)|
|스택 & 큐|이진 탐색|재귀|
|힙(Heaps)|병합정렬(Merge Sort)|동적프로그래밍(Dynamic Programming)|
|Vertor/ArrayList|퀵 정렬|big-O 시간 & 공간 복잡도|
|해시 테이블|

- 사용법
- 구현법
- 가능하다면 공간과 시간복잡도

## 실제 문제 살펴보기
면접문제는 일반적으로 어려우므로 즉시 답하지 못했더라도 괜찮다.

어떻게 답을 찾아가느냐가 더욱 중요하다.

면접문제를 받았을때 혹은 개인적으로 문제푸는 연습을 할때 아래의 단계를 따라 풀어가기를 바란다.

### 1. 듣기
- 문제 설명과 관련된 것이라면 어떤 정보든지 아주 집중해서 들어야 한다. 
- 최적 알고리즘을 설계하기 위해선 모든 정보가 필요할지도 모른다.
### 2. 예제
- 대부분의 예제들은 크기가 아주 작거나 특별한 사례인 경우가 많다.
- 직접 예제를 만들어서(그려서) 디버깅하라.
- 직접 만든 예제가 특별한 경우인가? 혹은 충분히 큰 입력인가?
### 3. 무식하게 풀기
- 우선은 빨리 무식한 방법(brute force)으로 풀길 바란다.
- 알고리즘의 효율을 높이려고 미리 애쓰지 말라.
- 아주 단순한 알고리즘 및 시간 복잡도를 먼저 말한 다음에 최적화를 시도하라.
- 아직 코딩할 단계는 아니다!
### 4. 최적화
- BUD 최적화를 통해 무식하게 푼 방법을 개선하거나 아래의 방법을 시도해 본다.
1. 간과한 부분이 있는지 생각해보자. 보통의 경우 문제에서 언급된 정보를 모두 사용해야 한다.
2. 예제를 손으로 풀어 본 뒤 여러분의 사고 과정을 되짚어 보라. 어떻게 풀었는가?
3. '잘못된' 방법으로 문제를 풀어 본 뒤 왜 알고리즘이 틀렸는지 생각해 보라. 여기서 발견된 문제들을 해결할 수 있는가?
4. 시간과 공간의 비용-이익 관계를 고려하라. 이때 정렬이나 해시테이블이 유용하다.
```
#BUD 최적화
병목현상(Bottlenecks)
불필요한 작업(Unnecessary Work)
중복되는 작업(Duplicated Work)
```
### 5. 검토하기
- 최적의 해법을 찾았다면, 다시 한번 자세하게 검토해 보라.
- 코딩을 시작하기 전에 세밀한 부분을 제대로 알고 있는지 확인할 필요가 있다.
### 6. 구현하기
- 여러분의 목적은 아름다운 코드를 작성하는것이다.
- 시작부터 코드를 모듈화시키고 아름답지 않은 부분은 리팩터링(refactoring)해서 깔끔하게 만들라.
```
#끊임없이 설명하라!
면접관은 여러분이 문제를 어떻게 풀고있는지 알고싶어 한다.
```
### 7. 테스트
다음의 순서로 테스트 해보길 바란다.
1. 개념적 테스트: 마치 코드 리뷰를 하듯이 자세하기 코드를 훑어보며 테스트 하기
2. 특이하거나 표준적이지 않은 코드
3. 산술 연산 혹은 널(null) 노드와 같이 실수가 날 만한 부분
4. 작은 크기의 테스트들. 큰 크기의 테스트보다 빨리 검증 가능하고 효율적
5. 특이하거나 극단적인 입력

버그를 찾았다면 신중을 기해서 고치라.

## 최적화 및 문제풀이 기술 #1: BUD를 찾으라
- 병목현상(Bottlenecks)
- 불필요한 작업(Unnecessary Work)
- 중복되는 작업(Duplicated Work)

알고리즘이 비효율적으로 동작하는 가장 흔한 이유가 바로 이 세가지.

무식한 방법 알고리즘에서 위의 세가지 현상을 찾아본뒤

그것을 반복하면서 점진적으로 개선해나가면 된다.

### 병목현상(bottlenecks)
병목현상(bottlenecks)란 전체 수행시간을 잡아먹는 부분을 의미한다.

- 어떤 부분 때문에 알고리즘이 느려지는 경우
```
# 알고리즘이 두부분으로 나눠져있다
1. O(NlogN)
2. O(N)
두번째 단계를 줄일 수 있지만 별 의미가 없을것이다.
왜냐하면 O(NlogN)이 이 알고리즘의 병목점이기 때문이다.
```
- 검색을 여러번 하는 것처럼 반복적으로 수행하는 부분이 여러 개 있는 경우
    - 전반적인 수행시간에 엄청난 영향력을 가진다.

```
예제: 서로 다른 정수로 이루어진 배열이 있을 때 두 정수의 차이가 k인 쌍의 개수를 세라. 예를들어 주어진 배열이 [1,7,5,9,2,12,3]이고 k=2면, 두 정수의 차이가 2인 쌍은 다음과 같이 네개가 존재한다. (1,3),(3,5),(5,7),(7,9)
```
1. 무식한 방법 O(N^2): 배열의 원소를 처음부터 차례로 훑어가면서 나머지 원소들과 쌍을 만든다.
    - 병목점: 두번째 원소를 반복적으로 찾을 때
2. 정렬된 배열로 이진 탐색 O(NlogN): 배열을 먼저 정렬 한 뒤 두번째 요소는 이진탐색으로 쌍을 만든다.
    - 병목점: 정렬되지 않는 배열을 이용
3. 해시 테이블 사용 O(N): 배열의 모든 원소를 해시 테이블에 넣은 뒤 이 해시 테이블을 통해 x+k 혹은 x-k가 존재하는지 확인.

### 불필요한 작업(unnecessary work)
```
예제: a, b, c, d가 1에서 1000 사이에 있는 정수 값 중 하나 일 때 a^3+b^3=c^3+d^3을 만족하는 몯느 자연수를 출력하시오.
```
1. 무식한 방법: O(n^4)
```
n = 100
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            for d from 1 to n
                if a^3+b^3 == c^3+d^3
                    print a, b, c, d
```
2. 만족하는 d의 값은 하나: : O(n^4)
```
n = 100
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            for d from 1 to n
                if a^3+b^3 == c^3+d^3
                    print a, b, c, d
                    break // d의 루프에서 빠져나온다
```
하지만 전체시간복잡도 개선에 별다른 영향을 주진 않는다

3. 간단한 수식을 통해 d를 찾을 수 있다: O(n^3)
```
n = 100
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            d = pow(a^2+b^3-c^3, 1/3) // 정수로 반올림한다
            if a^3+b^3 == c^3+d^3 // 실제 d값이 수식을 만족하는지 확인한다.
                print a, b, c, d
```
### 중복되는 작업(duplicated work)








## 최적화 및 문제풀이 #2 : 스스로 풀어보라 DIY(Do It Yourself)

- 직관적으로 문제를 풀어 나가는 노력을 하기 바람.


```
예제 : 길이가 작은 문자열 s와 길이가 긴 문자열 b가 주어졌을 때, 문자열 b 안에 존재하는 문자열 s의 모든 순열을 찾는 알고리즘을 설계하라. 각 순열의 위치를 출력하면 된다.
```

- 접근 방식에따라 알고리즘의 성능이 갈림.
- 순열이란 문자열에 등장하는 문자의 순서를 재배치하는 것과 같음.
- s의 문자들이 연속해서 등장하기만 한다면 b에서 임의의 순서대로 배치되어소 상관없다.

- 대부분의 지원자의 경우
    - s에서 가능한 모든 순열을 나열한 후 b에서 찾기.
    - 이 경우 순열의 개수가 S! -> O(S! * B)
    - 이때 S는 문자열의 길이, B는 문자열 b의 길이


<br>

- 좀더 괜찮은 알고리즘(손으로 직접 풀기)

s : abbc  
b : cbabadcbbabbcbabaabccbabc

- b중 어디에 s의 순열이 존재하는지 확인

s : abbc  
b : cbabadcbbabbcbabaabccbabc

cbab
abbc
cbab
cbbab
bcba
babc
cbab

- 대부분의 사람들이 다음 두 가지 방법 중 하나를 택함.
1. s의 길이가 4이므로 b를 4개씩 끊어서 차례로 살펴본 뒤 s의 순열을 만족하는지 확인한다.

2. b의 문자를 앞에서부터 차례로 살펴보면서 s에 속한 문자가 보일 때마다 그다음 문자를 포함한 4개의 문자열이 s의 순열을 만족하는지 확인힌다.

- 위의 방법의 수행시간은 대략
    - O(B * S), O(B * SlogS), O(B * S^2) 중 하나가 됨.
    - 뭐든 간에 이전보다 훨씬 나음.



- 문제에 적합하고, 크기가 크며, 구체적인 예제에 대해 직관적으로 풀길 바람.
- 직관적으로 푸는 과정을 역으로 이용하여 알고리즘을 설계
- 특히 자신도 모르게 수행한 최적화 방식을 잘 이해하고 알고리즘을 설계해야함.




## 최적화 및 문제풀이 #3 : 단순화 일반화하라

#### 단순화 및 일반화를 이용한 접근법
- 자료형과 같은 제약조건을 단순화하거나 변형시킨다.
- 단순화된 버전의 문제를 푼다.
- 단순화된 문제의 알고리즘이 완성되면 해당 알고리즘을 보다 복잡한 형태로 다듬는다.


```
예제 : 랜섬 노트(ransom note)는 잡지에서 오린 단어를 이용해서 만들어 낸 새로운 문장을 의미한다. 잡지(문자열)가 주어졌을 때, 그 잡지에서 문자열로 표현된 특정 랜섬노트를 만들 수 있는지 어떻게 확인할까?
```

- 문제를 단순화한 경우
    - 잡지에서 단어 대신 글자를 하나씩 오린다고 가정.
    - 배열을 하나 만들어 글자의 출현 빈도를 세기만 하면 풀 수 있다.
    - 배열의 각 원소는 글자 하나에 대응
    - 랜섬 노트 내에서 각 문자가 출현한 횟수를 센 다.
    - 그 다음, 잡지를 훑어 가며 각 문자의 횟수가 랜섬 노트에 출현한 문자의 횟수보다 같거나 많은지 확인한다.

- 문제를 일반화한 경우
    - 배열을 이용하여 글자의 출현 빈도를 세지 않고 해시테이블을 사용.



## 최적화 및 문제풀이 #4 : 초기 사례(base case)로 부터 확장하기(build)

- 초기 사례(n=1)에 대한 문제를 해결
- 해법을 확장하여 n=2, n=3 과 같이 복잡한 문제를 해결하여 해법을 구함.


```
예제 : 문자열의 모든 순열을 계산하는 알고리즘을 설계하라. 문제를 단순화 하기 위해, 모든 문자는 문자열 내에서 고유하게 등장한다고 가정한다.
```

- 입력 문자열로 abcdefg가 주어졌다고 가정

```
Case "a" => {"a"}
Case "ab" => {"ab","ba"}
Case "abc" => ?
```
- 추가 해야할 문자은 c 뿐이므로 가능한 지점에 c를 다 넣는다.

```
P("abc") = "c"를 P("ab")에 있는 모든 문자열의 모든 위치에 삽입한다.
P("abc") = "c"를 {"ab","ba"}에 있는 문자열의 모든 위치에 삽입힌다..
P("abc") = merge({"cab","acb","abc"},{"cba,bca,bac"})
P("abc") = {"cab","acb","abc","cba","bca","bac"}
```

- 위 패턴을 통해 일반적인 재귀 알고리즘을 만든다.
- 문자열 s1 ... sn의 순열을 구하는 경우, 마지막 문자열을 잠시 제외
- s1 ... sn-1의 순열을 모두 구한 뒤, 그 리스트에 있는 문자열 각각의 모든 지점에 sn을 삽입.



## 최적화 및 문제풀이 #5 : 자료구조 브레인스토밍

- 너저분하나 자주 통하는 방법
- 단순히 일련의 자료구조를 차례로 살펴보면서 하나씩 적용

```
예제 : 임의의 숫자를 만들어 낸 뒤 확장 가능한 배열에 차례로 저장한다. 새로운 입력이 들어올 때마다 중간값(median)을 구하면 어떻게 해야 하는가?
```

- 브레인 스토밍 과정
    - 연결리스트
        - 수열을 정렬하거나 특정숫자에 바로 접근하는 경우에 취약함
    - 배열
        - 이미 배열은 주어져 있으며 배열에 저장된 수를 정렬된 상태로 유지하는데 비용이 큼.
    - 이진 트리
        - 순서를 유지하는데 강점이 있음. 완벽히 균형 잡힌 상태인 경우 트리의 가장 꼭대기에 위치한 원소가 중간값이 됨.
        하지만, 가운데 있는 두 원소가 동시에 트리 꼭대기에 놓일 수 없다. 

    - 힙 
        - 수열의 순서와 최댓값과 최솟값을 유지하기에 매우 좋은 자료구조
        - 힙을 두개 사용하면 큰수 절반과 작은 수 절반을 분리하여 추적 가능
        - 큰 수 절반은 최소 힙(min heap)에 배치하고 이중 가장 작은 수를 루트에 배치, 작은 수 절반은 최대 힙(max heap)에 배치하고 이중 가장 큰수는 root에 배치.
        - 이렇게 하면 중간값 후보 원소 두 개가 루트에 놓임.
        - 두 힙의 크기가 변하면 원소가 더 많은 힙에서 원소 하나를 덜어내 다른 힙에 넣는 방식으로 빠르게 균형을 맞춤

        
## 가능한 최선의 수행시간.(Best Conceivable Runtime(BCR))

- 어떤 문제를 푸는 데 상상할 수 있는 모든 해법 중 수행 시간이 가장 빠른것을 의미.
- 가능한 최선의 수행시간을 생각해 보는 것 자체로도 문제를 푸는 힌트를 발견할수 있다.


```
예 : 길이가 A와 B인 배열 두 개가 주어졌을 때 두 배려에 공통으로 들어있는 원소의 개수가 몇 개인지 세는 경우.
```
- 각 배열의 원소를 한 번씩은 건드려봐야 하기 때문에 어떤 알고리즘이든 O(A+B)보다 빠를 수 없다.
- 따라서 이 문제의 BCR은 O(A+B)


```
예 : 배열에 들어 있는 모든 값의 쌍을 출력 해야하는 경우.
```
- 출력해야하는 쌍의 개수가 N^2
- 따라서 O(N^2)

```
예 : 합이 k가 되는 모든 쌍을 출력하라(원소의 값은 모두 다름)
```
- O(N^2) 로 볼수도 있으나, 모든 쌍을 살필 필요는 없음.

- 가능한 최선의 수행시간과 최선의 경우의 모든 수행 시간에는 관계가 없음.

- 가능한 최선의 수행시간
    - 상상할 수 있는 모든 해법 중 가장 빠른 알고리즘의 수행 시간을 의미.

- 최선의 경우의 수행 시간
    - 특정 알고리즘이 가장 빠르게 동작할 경우의 수행시간.

- 이 둘은 아무 관계가 없다.


#### BCR 사용법에 관한 예제
```
문제 : 정렬된 배열 두 개가 주어졌을 때 공통으로 들어있는 원소의 개수를 찾으라. 두 배열의 길이는 같고 하나의 배열 안에서 동일한 원소는 하나만 존재한다.

A : 13 27 35 40 49 55 59
B : 17 35 39 40 55 58 60

```
- 무식한 방법
    - A의 각 원소가 B에 존재하는지 찾아보는 것.
    - A에 들어있는 N개의 원소에 대해 B에서 O(N)의 검색을 해야한다.
    - 따라서 이 방법은 O(N^2)

- 이 문제의 BCR은 O(N)
    - 원소는 총 2N개가 있으며 모든 원소를 적어도 한번씩은 살펴봐야한다.

##### 최적 알고리즘 : ?
##### BCR : O(N)

### O(N^2)에서 좀더 나은 알고리즘 찾기

- 수행 시간은 객관식 문제가 아니라는것을 명심
- 추측하지 말고 직접 유도할것.
- BCR을 이용하면 어떤 부분을 줄일수 있는지 힌트를 얻을 수 있다.

<br>

- 배열이 정렬되어 있다고 가정한다면 O(N)보다 빠르게 탐색 가능
- 이진탐색을 이용 O(log N)

##### 무식한 방법 : O(N^2)
##### 개선된 알고리즘 : O(N log N)
##### 최적 알고리즘 : ?
##### BCR : O(N)

<br>

- 좀더 개선해서..
- B의 원소를 해시테이블에 모두 넣으면 O(N)이 된다.
- 그 다음 A의 모든 원소를 하나씩 살펴보면서 해당 원소가 B에도 있는지 해시테이블을 찾으면됨.
- 해시테이블의 수행시간은 O(1)이므로 전체 수행 시간은 O(N)이됨.


### 공간 복잡도를 개선하기

- 이미 O(N) 공간에서 최선의 수행 시간으로 동작하는 알고리즘을 알고 있음.
- 해시 테이블은 추가 공간을 사용하므로 제외
- 현재까지 최선의 알고리즘 중 추가 공간을 사용하지 않는것은 이진 탐색.

A : 13 27 35 40 49 55 59  
B : 17 35 39 40 55 58 60

```
1. A[0] = 13을 B에서 이진 탐색. 찾지 못함
2. A[1] = 27을 B에서 이진 탐색. 찾지 못함
3. A[2] = 35를 B에서 이진 탐색. B[1]에서 찾음
4. A[3] = 40을 B에서 이진 탐색. B[5]에서 찾음
5. A[4] = 49를 B에서 이진 탐색. 찾지 못함
```
- BUD를 생각해 볼때, 탐색이 병목 지점이 된다.
- 불필요한 부분은 A[3]=40을 찾는과정이다.
- B[1]이 35라는 사실을 바로 전에 발견했으므로 40은 B[1] 이전에 존재 할 수 없다.
- 따라서 각각의 이진 탐색은 이전에 탐색이 끝난 위치에서 시작하면 됨.
- 허나 이진 탐색을 구지 사용하지 않고도, 단지 선형 탐색으로도 같은 효과를 낼수 있음.
- B에서 선형 탐색하는 부분이 단순히 이전 위치를 찾는 과정이라면, 전체 과정이 선형 시간에 가능하다는 사실을 알 수 있음.

```
1. A[0] = 13을 B에서 선형 탐색한다. B[0] = 17에서 시작한다.  B[0] = 17 에서 종료. 찾지 못함.

2. A[1] = 27을 B에서 선형 탐색한다. B[0] = 17에서 시작한다.  B[1] = 35 에서 종료. 찾지 못함.

3. A[2] = 35을 B에서 선형 탐색한다. B[1] = 35에서 시작한다.  B[1] = 35 에서 종료. 찾음.

4. A[3] = 40을 B에서 선형 탐색한다. B[2] = 37에서 시작한다.  B[3] = 40 에서 종료. 찾음.

5. A[4] = 49을 B에서 선형 탐색한다. B[0] = 40에서 시작한다.  B[4] = 55 에서 종료. 찾음.

6. ...

```
- 정렬된 두 배열을 병합(merge)하는 알고리즘과 매우 유사.
- O(N)과 O(1)공간에 동작.
- 이보다 더 개선할 수 없음.


### 오답에 대한 대처법
- 답을 평가할때 맞냐 틀렸냐로 보지 않는다.
    - 얼마나 최종 답안이 최적 해법에 근접한가
    - 최종 답안을 내는데 시간이 얼마나 걸렸나.
    - 힌트를 얼마나 필요로 했는가.
    - 얼마나 코드가 깔끔한가.

- 지원자들을 상대적으로 평가한다.
    - 아주 쉬운 문제는 빠른 시간 내에 최적의 답을 구할 수 있어야하나,
    - 아주 문제가 어려웠다면, 실수를 몇 군데 하더라도 대개는 받아들여진다.

- 대부분의 문제가 아주 어렵기 때문에 단번에 최적 해법을 말하기는 어렵다.


### 알고 있던 문제가 면접에 나왔을 때
- 이미 알고 있던 문제가 나왔다면 사실대로 말하는것을 추천
- 이미 알고 있는 문제를 풀게되면 면접관은 제대로 평가하기 힘듬
- 만약 이를 숨기고 문제를 알고 풀었다는 사실이 밝혀지면 부정적인 평가가 됨.

### 면접용으로 '완벽한' 언어
- 가장 편하게 코딩할 수 있는 언어를 선택.
- 만약 여러개가 존재한다면, 다음을 염두에 둘것.


#### 널리 사용되는 언어
- 면접관도 알고 있는 언어로 코딩하는 것이 바람직함.

#### 언어 가독성
- 대부분의 사람들은 C, C++, java와 같은 비슷한 문법의 언어를 사용해 본 경험이 있다.
- 하지만 스칼라(Scala) 혹은 오브젝티브-C(Objectiv-C)와 같은 언어는 이들과 상당히 다른 방식의 언어 이다.

#### 잠재적인 문제점
- 언어에 종속된 문제점을 해결해야하는 경우가 있다.
- C, C++은 일반적인 버그는 물론 메모리관리, 포인터 때문에 생기는 문제점들도 해결해야한다.

#### 얼어가 얼마나 장황한지
- java는 python과 비교해 봤을 때 상당히 장황한 언어이다.

```py
dict = {"left": 1, "right": 2, "top" : 3, "bottom":4}
```

```java
HashMap dict = new HashMap();
dict.put("left",1);
dict.put("right",2);
dict.put("top",3);
dict.put("bottom",4);
```

#### 사용하기 쉬운 언어
- 파이썬을 이용하면 함수에서 복수의 값을 반환하기 굉장히 쉬움
- 자바에서 같은 기능을 사용하려면 별도의 클래스 추가가 필요함.
- 특정 문제를 해결할 때 이와 같은 언어적 특성을 고려.


### 어떤 코드가 좋아 보이나
- 정확도 
    - 예상 가능한, 혹은 불가능한 입력에 대해서, 코드는 정확히 동작해야 한다.

- 효율성
    - 시간과 공간 두 가지 측명에서 모두 효율성이 좋은 코드여야 한다.
    - O 표기법에서 시간 효율성을 계산하면 상수 인자를 모두 무시해도 되지만 실 생활에선 상수 인자가 매우 중요할 수도 있다.

- 간략화
    - 코드 100줄 짜리를 10줄로 작성할 수 있다면, 그렇게 해야한다.

- 가독성
    - 다른 개발자가 코드를 읽고 이해할 수 있어야한다.
    - 필요한 곳에는 주석이 필요하다.
    - 비트 쉬프트 연산을 많이 사용한 코드는 가독성이 떨어진다.

- 관리 가능성
    - 유지보수하기 쉬운 코드여야한다.


#### 적절한 자료구조를 사용하라.
- 문제에 맞는 자료구조를 사용하라.

#### 적절한 코드의 재사용
```
예 : 문자열로 전달된 이진수의 값과 문자열로 전달된 16진수 값이 일치하는지를 검사하는 문제
```
```java
boolean compareBinToHex(String binary, String hex){
    int n1 = convertFromBase(binary,2);
    int n2 = convertFromBase(hex, 16);
    if(n1<2 || n2 <0){
        return false;
    }
    return n1 == n2;
}

int convertFromBase(String number, int base){
    if(base < 2 || base > 10 && base != 16)) return -1;
    int value = 0;
    for (int i = number.length() - 1; i>=0; i--){
        int digit = digitToValue(number.charAt(i));
        if(digit < 0 || digit >= base){
            return -1;
        }
        int exp = number.length() - 1 - i;
        value+=digit*Math.pow(base, exp);
    }
    return value;
}

int digitToValue(char c) {...}
```
- 이진수 변환 함수와 16진수를 변환하는 함수를 별도로 분리해서 작성 할 수 도 있으나 그렇게 되면 코드가 복잡해지고 유지보수도 어려워진다.


#### 모듈화
- 관계 없는 코드들을 별도 메서드로 나눈다.
- 코드를 좀 더 쉽게 유지보수할 수 있고, 가독성이 좋아지며, 테스트 하기도 쉬워진다.

```
예 : 정수 배열의 최솟값과 최댓값 원소를 바꾸는 코드를 작성
```

```java
void swapMinMax(int[] array){
    int minIndex = 0;
    for (int i = 1; i < array.length; i++){
        if(array[i] < array[minIndex]){
            minIndex = i;
        }
    }

    int maxIndex = 0;
    for(int i = 1; i < array.length; i++){
        if(array[i] > array[maxIndex]){
            maxIndex = i;
        }
    }

    int temp = array[minIndex];
    array[minIndex] = array[maxIndex];
    array[maxIndex] = temp;
}
```
```java
//관계성 없는 코드를 분리

void swapMinMax(int[] array){
    int minIndex = getMinIndex(array);
    int maxIndex = getMaxIndex(array);
    swap(array, minIndex, maxIndex);
}

int getMinIndex(int[] array){...}
int getMaxIndex(int[] array){...}
void swap(int[] array, int m, int n){...}
```
- 코드가 복잡해 질수록 모듈화 원칙을 지킬것.
- 가독성도 높아지고 유지보수도 쉽다.

#### 유연하고 튼튼한 코드
- 특정 값을 직접 대입하는 대신 변수를 사용하거나, 
- 템플릿/제네릭을 사용하여 작성된것을 의미하기도 함.
- 다만 필요할때만 하는것이 좋음.


#### 오류 검사
- 신중한 프로그래머는 입력의 형식에 어떠한 가정도 하지 않는다.
- 대신, ASSERT나 if문을 통해서 입력의 형태가 기대한 방식과 같은지 아닌지 검사.

```java
int convertToBase(String number, int base){
    
    //Base가 올바른 값인지 검사
    if(base < 2 || base > 10 && base != 16)) return -1;
    int value = 0;

    for (int i = number.length() - 1; i>=0; i--){
        int digit = digitToValue(number.charAt(i));

        //각 숫자가 허용된 범위 내에 있는지 확인.
        if(digit < 0 || digit >= base){
            return -1;
        }
        int exp = number.length() - 1 - i;
        value+=digit*Math.pow(base, exp);
    }
    return value;
}
```
- 테스트는 실제 제품 코드를 작성할 때 아주 중요하며, 면접을 볼 때에도 마찬가지.
- 오류 검사를 위한 코드를 작성할 것.
- 만약 간단한 if 문으로 검사 코드를 추가할 수 없다면, 코드가 들어갈 공간을 남겨두고 면접관에게 나머지 코드를 완성한 다음에 채우겠다고 말할것.

## 포기하지 말라
- 면접은 원래 어렵다
- 어려운 문제에 마주치는 상황은 놀라운 일이 아니다.
- 추가점수를 받고싶다면 어려운 문제를 즐기며 푸는 모습을 보여라.
