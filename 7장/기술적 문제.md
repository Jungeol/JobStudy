# 기술적 문제
기술적문제는 어렵지만, 사실 논리적 방법이 존재한다
## 준비하기
1. 직접 풀어보도록 노력하라
    - 포기하지말고 꼭 직접 풀기
    - 공간과 시간 효율에 대해 생각하기
2. 코드를 종이에 적으라
    - 언제나 IDE를 사용할수 있는건 아니다
3. 코드를 테스트 하라
    - 일반적인 경우 뿐 아니라, 기본 조건, 오류 발생 조건 등을 전부 테스트 해야한다.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라
    - 실수 목록을 만들고 면접에서는 같은 실수를 저지르지 않도록 유의하라

가상 면접을 가능한 많이 해보길 바람

## 알고있어야 할 것들
### 핵심 자료구조, 알고리즘, 기본개념
대부분의 면접관은 이진 트리의 균형을 맞추는 특정 방법이나 기타 복잡한 알고리즘에 대한 질문을 하지 않는다.
여러분에게 기대하는건 기본기다. 반드시 알아야 할것은 아래와 같다.

|자료구조|알고리즘|개념|
|-|-|-|
|연결리스트(Linked List)|너비 우선 탐색(Breadth-First Search)|비트 조작(Bit Manipulaion)|
|트리,트라이(Tries),그래프|깊이 우선 탐색(Depth-First Search)|메모리(스택vs힙)|
|스택 & 큐|이진 탐색|재귀|
|힙(Heaps)|병합정렬(Merge Sort)|동적프로그래밍(Dynamic Programming)|
|Vertor/ArrayList|퀵 정렬|big-O 시간 & 공간 복잡도|
|해시 테이블|

- 사용법
- 구현법
- 가능하다면 공간과 시간복잡도

## 실제 문제 살펴보기
면접문제는 일반적으로 어려우므로 즉시 답하지 못했더라도 괜찮다.

어떻게 답을 찾아가느냐가 더욱 중요하다.

면접문제를 받았을때 혹은 개인적으로 문제푸는 연습을 할때 아래의 단계를 따라 풀어가기를 바란다.

### 1. 듣기
- 문제 설명과 관련된 것이라면 어떤 정보든지 아주 집중해서 들어야 한다. 
- 최적 알고리즘을 설계하기 위해선 모든 정보가 필요할지도 모른다.
### 2. 예제
- 대부분의 예제들은 크기가 아주 작거나 특별한 사례인 경우가 많다.
- 직접 예제를 만들어서(그려서) 디버깅하라.
- 직접 만든 예제가 특별한 경우인가? 혹은 충분히 큰 입력인가?
### 3. 무식하게 풀기
- 우선은 빨리 무식한 방법(brute force)으로 풀길 바란다.
- 알고리즘의 효율을 높이려고 미리 애쓰지 말라.
- 아주 단순한 알고리즘 및 시간 복잡도를 먼저 말한 다음에 최적화를 시도하라.
- 아직 코딩할 단계는 아니다!
### 4. 최적화
- BUD 최적화를 통해 무식하게 푼 방법을 개선하거나 아래의 방법을 시도해 본다.
1. 간과한 부분이 있는지 생각해보자. 보통의 경우 문제에서 언급된 정보를 모두 사용해야 한다.
2. 예제를 손으로 풀어 본 뒤 여러분의 사고 과정을 되짚어 보라. 어떻게 풀었는가?
3. '잘못된' 방법으로 문제를 풀어 본 뒤 왜 알고리즘이 틀렸는지 생각해 보라. 여기서 발견된 문제들을 해결할 수 있는가?
4. 시간과 공간의 비용-이익 관계를 고려하라. 이때 정렬이나 해시테이블이 유용하다.
```
#BUD 최적화
병목현상(Bottlenecks)
불필요한 작업(Unnecessary Work)
중복되는 작업(Duplicated Work)
```
### 5. 검토하기
- 최적의 해법을 찾았다면, 다시 한번 자세하게 검토해 보라.
- 코딩을 시작하기 전에 세밀한 부분을 제대로 알고 있는지 확인할 필요가 있다.
### 6. 구현하기
- 여러분의 목적은 아름다운 코드를 작성하는것이다.
- 시작부터 코드를 모듈화시키고 아름답지 않은 부분은 리팩터링(refactoring)해서 깔끔하게 만들라.
```
#끊임없이 설명하라!
면접관은 여러분이 문제를 어떻게 풀고있는지 알고싶어 한다.
```
### 7. 테스트
다음의 순서로 테스트 해보길 바란다.
1. 개념적 테스트: 마치 코드 리뷰를 하듯이 자세하기 코드를 훑어보며 테스트 하기
2. 특이하거나 표준적이지 않은 코드
3. 산술 연산 혹은 널(null) 노드와 같이 실수가 날 만한 부분
4. 작은 크기의 테스트들. 큰 크기의 테스트보다 빨리 검증 가능하고 효율적
5. 특이하거나 극단적인 입력

버그를 찾았다면 신중을 기해서 고치라.

## 최적화 및 문제풀이 기술 #1: BUD를 찾으라
- 병목현상(Bottlenecks)
- 불필요한 작업(Unnecessary Work)
- 중복되는 작업(Duplicated Work)

알고리즘이 비효율적으로 동작하는 가장 흔한 이유가 바로 이 세가지.

무식한 방법 알고리즘에서 위의 세가지 현상을 찾아본뒤

그것을 반복하면서 점진적으로 개선해나가면 된다.

### 병목현상(bottlenecks)
병목현상(bottlenecks)란 전체 수행시간을 잡아먹는 부분을 의미한다.

- 어떤 부분 때문에 알고리즘이 느려지는 경우
```
# 알고리즘이 두부분으로 나눠져있다
1. O(NlogN)
2. O(N)
두번째 단계를 줄일 수 있지만 별 의미가 없을것이다.
왜냐하면 O(NlogN)이 이 알고리즘의 병목점이기 때문이다.
```
- 검색을 여러번 하는 것처럼 반복적으로 수행하는 부분이 여러 개 있는 경우
    - 전반적인 수행시간에 엄청난 영향력을 가진다.

```
예제: 서로 다른 정수로 이루어진 배열이 있을 때 두 정수의 차이가 k인 쌍의 개수를 세라. 예를들어 주어진 배열이 [1,7,5,9,2,12,3]이고 k=2면, 두 정수의 차이가 2인 쌍은 다음과 같이 네개가 존재한다. (1,3),(3,5),(5,7),(7,9)
```
1. 무식한 방법 O(N^2): 배열의 원소를 처음부터 차례로 훑어가면서 나머지 원소들과 쌍을 만든다.
    - 병목점: 두번째 원소를 반복적으로 찾을 때
2. 정렬된 배열로 이진 탐색 O(NlogN): 배열을 먼저 정렬 한 뒤 두번째 요소는 이진탐색으로 쌍을 만든다.
    - 병목점: 정렬되지 않는 배열을 이용
3. 해시 테이블 사용 O(N): 배열의 모든 원소를 해시 테이블에 넣은 뒤 이 해시 테이블을 통해 x+k 혹은 x-k가 존재하는지 확인.

### 불필요한 작업(unnecessary work)
```
예제: a, b, c, d가 1에서 1000 사이에 있는 정수 값 중 하나 일 때 a^3+b^3=c^3+d^3을 만족하는 몯느 자연수를 출력하시오.
```
1. 무식한 방법: O(n^4)
```
n = 100
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            for d from 1 to n
                if a^3+b^3 == c^3+d^3
                    print a, b, c, d
```
2. 만족하는 d의 값은 하나: : O(n^4)
```
n = 100
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            for d from 1 to n
                if a^3+b^3 == c^3+d^3
                    print a, b, c, d
                    break // d의 루프에서 빠져나온다
```
하지만 전체시간복잡도 개선에 별다른 영향을 주진 않는다

3. 간단한 수식을 통해 d를 찾을 수 있다: O(n^3)
```
n = 100
for a from 1 to n
    for b from 1 to n
        for c from 1 to n
            d = pow(a^2+b^3-c^3, 1/3) // 정수로 반올림한다
            if a^3+b^3 == c^3+d^3 // 실제 d값이 수식을 만족하는지 확인한다.
                print a, b, c, d
```
### 중복되는 작업(duplicated work)
