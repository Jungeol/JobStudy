# 06. 수학 및 논리 퍼즐
## 소수
- 모든 자연수는 소스의 곱으로 나타낼 수 있다.
```
84 = 2**2 * 3**1 * 5**0 * 7**1 * 11*0 * 13*0 * 17*0 * ...
```

### 가분성(divisibility)
```
x = 2**j0 * 3 ** j1 * 5**j2 * ...이고
y = 2**k0 * 3 ** k1 * 5**k2 * ...일때
x가 y로 나누어 떨어지면 모든 i에서 j <= k를 만족해야한다.
```
최대공약수
```
gcd(x, y) = 2**min(j0, k0) * 3**min(j1, k1) * 5**min(j2, k2) * ...
```
최대공배수
```
lcm(x, y) = 2**max(j0, k0) * 3**max(j1, k1) * 5**max(j2, k2) * ...
```
gcd * lcm
```
gcd * lcm = xy
```

## 소수판별
- 너무 흔한 문제

1. 어떤수 n이 소수인지 여부를 판별하는 가장 단순한 방법은 2에서 n-1 루프를 돌면서 나누어 보는것
```java
boolean primeNaive(int n) {
    if (n < 2) {
        return false;
    }
    for (int i = 2; i < n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```
2. 루프를 n이 아닌 n의 제곱근까지만 돌면 된다.
```java
boolean primeNaive(int n) {
    if (n < 2) {
        return false;
    }
    int sqrt = (int) Math.sqrt(n);
    for (int i = 2; i < sqrt; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
```
- n을 나누는 모든 숫자a는 그에대한 보수b(a*b=n)가 반드시 존재하기 때문이다.
- 만일 a > sqrt(n)이라면 b < sqrt(n)이다(sqrt(n)**2 = n이므로).
- b에서 이미 검사했으므로 n이 소수인지를 알아보기위해 a까지 검사할 필요는 없다.

### 소수 목록 만들기: 에라토스테네스의 체
- 굉장히 효율적인 방법
- 소수가 아닌 수들은 반드시 다른 소수로 나누어진다는 사실에 기반해서 동작한다.
동작방법
1. 처음 주어진 리스트는 1부터 max까지의 모든 수로 구성되어 있음
2. 처음에는 2로 나누어지는 모든 수를 리스트에서 없앰
3. 그후 다음 소수, 즉 아직 지워지지 않은 수 중 가장 작은 수를 찾음
4. 그리고 또다시 그 수로 나누어지는 모든 수를 리스트에서 없앰
5. max까지 반복

```java
boolean[] sieveOfEratosthenes(int max) {
    boolean[] flags new boolean[max + 1];
    int count = 0;

    init(flags); // 0과 1번 인덱스를 제외한 모든 원소값을 true로 초기화
    int prime = 2;

    while (prime <= Math.sqrt(max)) {
        /* prime의 배수들을 지워나간다. */
        crossOff(flags, prime);

        /* 그다음 true로 세팅된 인덱스를 찾는다. */
        prime = getNextPrime(flags, prime);
    }
}

void crossOff(boolean[] flags, int prime) {
    /* prime의 배수들을 제거해나간다. k < prime인 k에대한 k * prime은
     * 이전 루프에서 이미 제거되었을 것이므로 prime * prime부터 시작한다. */
     for (int i = prime * prime; i < flags.length; i += prime) {
         flags[i] = false;
     }
}

int getNextPrime(boolean[] flags, int prime) {
    int next = prime + 1;
    while (next < flags.length && !flags[next]) {
        next++;
    }
    return next;
}
```
그밖의 개선방법
- 배열에 홀수만 저장하는 방법: 메모리공간이 반으로 준다

## 확률
????

## 입을 열라
- 수수께끼 같은 문제를 만나면 당황하지말고 입을열러 말을하라.
- 면접관들이 원하는 것은 여러분이 문제를 어떻게공략해 나가는지 보는 것이다.

## 규칙과 패턴을 찾으라
- 많은경우에 문제를 풀다가 발견하는 규칙이나 패턴을 적어두면 도움이 된다.
예제 문제
```
끈이 두개있다. 각 끈은 태우는데 정확히 한 시간이 걸린다. 이 두끈을 이용해서 15분을 재려면 어떻게 해야 하는가?
단, 이끈의 밀도는 균일하지 않아서, 절반의 길이를 태우는데 드는 시간이 정확히 30분이라는 보장이 없다.
```
풀어가는 방법
```
규칙1: 태우는데 x분이 걸리는 끈과 y분이 걸리는 끈이 주어지면, x + y만큼의 시간을 잴 수 있다.

규칙2: 태우는 데 x분 걸리는 끈이 주어지면, x/2분을 잴 수 있다.

규칙3: 1번 끈을 태우는 데 x분 걸리고 2번 끈을 태우는 데 y분이 걸리면, 2번 끈을 태우는 시간을 (y-x)분이나 (y-x/2)분으로 바꿀 수 있다.
```
정답
```
1. 1번끈은 양쪽에 불을 붙이고, 2번 끈은 한쪽에만 불을 붙인다.
2. 1번끈이 다 타버리면 30분이 지난것.
3. 그시점에 2번끈의 다른 쪽에도 불을 붙인다.
4. 그러면 정확하게 15분뒤에 2번끈도 완전히 다 타버릴 것이다.
```

## 최악의 경우는?
- 수수께끼 종류의 문제 중 많은 수가 최악의 경우를 최소화 하는것과 연관이 있다.
- 어떤 행동을 최소화 하거나 지정된 횟수 안에 처리해야 하는 경우 등
- 초기의 어떤 결정을 통해 최악의 경우가 한쪽 방향으로 쏠리면, 그 결정을 다른방식으로 바꿔서 최악의 경우가 균형 잡히도록 할 수 있다.

예제
```
공이 아홉개 있다. 이 가운데는 여덟개는 무게가 같고 하나는 좀 무겁다.
여러분에게 저울이 하나 주어지는데, 이 저울로는 왼쪽과 오른쪽 중 어느쪽이 무거운지만 알 수 있다.
이 저울을 딱 2번만 사용해서 가장 무거운 공을 찾아라.
```

1. 먼저 떠올릴 수 있는 접근법은, 아홉 번째 공은 제쳐둔 채, 나머지 공을 네 개씩 두 그룹으로 나누는 것.
    1. 두 그룹을 비교한다.
        - 두그룹의 무게가 같으면 제친 공이 가장 무거운 공.
        - 아니면 무거운 그룹을 선택
    2. 무거운 그룹을 둘로 나눠 비교한다
        - 무거운 쪽 2개를 선택한다
    3. 무거운 그룹을 둘로 나눠 비교한다
        - 무거운 쪽 1개를 선택한다.
    - 최선의 경우 1번, 최악의 경우 3번

2. 공들을 두개씩 세 그룹으로 나눠서 보면
    1. 세 그룹 중 둘을 비교한다.
        - 무게가 같으면 제외한 그룹을 선택
        - 무게가 다르면 무거운 그룹을 선택
    2. 공 두개를 비교한다.
        - 무거운 쪽 1개를 선택
    - 최선의 경우 1번, 최악의 경우 2번

## 알고리즘 적 접근법
- 문제를 풀다가 막혔다면, 알고리즘 문제를 푸는 접근법(100쪽) 가운데 하나를 적용해보자.
- 수수께끼처럼 보이는 문제들 중 상당수는 기술적인 측면을 제거한 알고리즘 문제인 경우가 많다.
- 초기사례로부터의 확장법, 스스로 풀어보기가 특히 유용하게 쓰일 수 있다.
