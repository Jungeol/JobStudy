# 시스템 설계 및 규모 확장성
- 많이들 어렵게 생각하지만 그렇지 않음
- 실제 일을 하는것처럼 진행하면 됨
- 좋은 해법과 나쁜 해법은 있지만 완벽한 해법은 없다

## 문제를 다루는 방법
- 소통하라
- 처음에는 포괄적으로 접근하라
- 화이트보드를 사용하라
- 면접관이 우려하는 부분을 인정하라
- 가정을 할 때 주의하라
- 여러분이 생각하는 가정을 명확히 언급하라
- 필요하다면 어림잡아 보라
- 뛰어들라

## 시스템 설계: 단계별 접근법
### 1단계: 문제의 범위를 한정하라
- 문제의 주요한 특징을 한정시킴
### 2단계: 합리적인 가정을 만들라
- 합리적인 성능특성
### 3단계: 중요한부분을 먼저 그리라
- 시스템의 주요한 부분을 다이어그램으로
### 4단계: 핵심 문제점을 찾으라
- 설계한 시스템에서 발생할 수 있는 주된 문제
### 5단계: 핵심 문제점을 해결할 수 있도록 다시 설계하라
- 처음 그린 다이어그램을 바뀐 설계에 맞게 재구성

## 규모 확장을 위한 할고리즘: 단계별 접근법
### 1단계: 질문하라
- 문제를 제대로 이해하기위해 면접관에게 질문
### 2단계: 현실적 제약을 무시하라
- 메모리제약과 성능제약등이 없다고 가정하고 문제를 풀어봄
### 3단계: 현실로 돌아오라
- 컴퓨터 한 대에 저장할 수 있는 데이터의 크기가 얼마인지
- 데이터를 여러조각으로 쪼갰을 때 어떤 문제가 발생할지 생각해보라
### 4단계: 문제를 풀어라
- 3단계에서 문제를 해결하면 또다른 문제가 발생하고 그것을 또 해결하는 순환적 방법이 유용함

## 시스템 설계의 핵심 개념
### 수평적 vs. 수직적 규모 확장
- 수직적 규모 확장(vertical scaling): 특정 노드의 자원을 향상
- 수평적 규모 확장(horizontal scaling): 노드의 개수를 늘리는 방법
### 서버 부하 분산 장치(load balancer)
- 일반적으로 규모 확장성이 있는 웹사이트의 프론트엔드 부분은 서버 부하 분산 장치를 통해서 제공
- 이렇게 하기 위해선 서버 여러대가 근본적으로 똑같은 코드와 데이터를 사용하도록 하는 네트워크를 구현해놔야 한다
### 데이터베이스 역정규화(denormalization)와 NoSQL
- RDBMS의 Join연산은 시스템이 커질수록 굉장히 느려지므로 가능하면 피해야한다
- 역정규화(denormalization)가 이런 것들중 하나다
- 테이블을 조인하기보다는 데이터를 추가로 저장한다
- 혹은, NoSQL 데이터베이스를 사용할 수 있다. NoSQL은 Join연산을 사용하지 않으며, 규모확장성에 좋게 설계되어있다.

## 데이터베이스 분할(샤딩)
샤딩은 데이터를 여러컴퓨터에 나눠 저장하는 동시에 데이터가 어디에있는지 알 수 있는 방식을 말함.
- 수직적 분할(vertical partitioning):
    - 기본적으로 자료의 특성별로 분할하는 방식
    - 특정 테이블의 크기가 커지면 재분할 해야할 수도 있음
- 키 혹은 해시 기반 분할:
    - 간단하게는 mod(key, n)으로 나눠 저장하는 법
    - 서버의 개수가 고정되어 있어야 한다
    - 서버를 추가할때마다 재분배를 해야하는데 비용이 무척 크다
- 디렉터리 기반 분할:
    - 데이터를 찾을 때 사용되는 조회테이블(lookup)을 유지함
    - 상대적으로 서버를 추가하기 쉽지만
    - 단점
        - 조회 테이블이 단일 장애 지점(single point of failure)이 될 수 있음
        - 지속적으로 테이블을 읽는 행위가 전체성능에 영향을 미침

### 캐싱(caching)
- 인메모리 캐시를 사용하면 결과를 굉장히 빠르게 가져올 수 있다.
- 메모리 캐시는 key-value 쌍으로 갖는 간단한 구조로써 일반적으로 애플리케이션과 데이터 저장소 사이에 자리잡고 있다.
- 캐시를 할때는 쿼리와 그 결과를 캐싱하는 경우가 많고, 특정 객체를 캐시에 저장할 수도 있다.

### 비동기식 처리 & 큐
- 이상적이라면, 속도가 느린 연산은 비동기식(asynchronous)으로 처리해야 한다.
- 어떤경우에는 이 연산을 미리 해놓을 수도 있다.
```
1. 포럼 웹사이트
2. 메인페이지에 최근의 글들과 몇가지 코멘트를 보여주는 페이지를 보여줌
3. 큐에들어있는건 최근글과 코멘트를 다시만드는 것
4. 새로운 코멘트 하나때문에 캐시(cashe miss)가 남
5. 속도가 느린것보다 덜정확한 편이 낫다
```
- 작업이 매우 오래걸리는경우, 데이터를 가져오는데 몇분이 소요되는지 표시하고, 끝나면 알려주는 경우도 있다.

### 네트워크 성능 척도
- 대역폭(bandwidth): 단위시간에 전송할 수 있는 데이터의 최대치
- 처리량(throughput): 단위시간에 실제로 전송된 데이터의 양
- 지연속도(latency): 데이터를 전송하는데 걸리는 시간

지연시간은 무시되기 쉽지만 특정 상황에선 굉장히 중요한 역할을 한다.
처리량은 압축 등의 방법을통해 어떻게든 향상시킬 수 있지만, 지연시간을위해 할수 있는 일은 많지 않다.

### MapReduce
MapReduce 프로그램은 보통 굉장히 커다란 데이터를 처리하는데 사용된다
- Map은 데이터를 입력으로 받은 뒤 <key, value> 쌍을 반환한다
- Reduce는 key, 그리고 key와 관련된 value들을 입력으로 받은 뒤 나름의 처리과정을 거쳐 새로운 key, value를 반환한다. 결과를 또다른 Reduce로 넘길수도 있다.

MapReduce는 많은 과정을 병렬로 처리할 수 있게 도와주기 때문에 굉장히 커다란 데이터에 대해서도 규모 확장이 쉬워진다.

## 시스템 설계 시 고려할 점
- 실패(Failures): 시스템의 어떤 부분이든 실패의 가능성이 있으므로 대비책을 준비해야 한다.
- 가용성(availability) 및 신뢰성(reliability): 가용성은 사용가능한 시스템의 시간을 백분율로 표시한 것. 신뢰성은 특정 단위 시간에 시스템이 사용가능할 확률을 나타낸 것.
- 읽기 중심 vs. 쓰기중심: 
    - 쓰는 연산이 많다면, 큐를 사용하는 방법을 한번 생각
    - 읽는 연산이 많다면, 캐시를 사용하는것이 좋을수 있다
- 보안(security): 보안위협은 시스템에 엄청난 해를 가할 수 있다.

## '완벽한' 시스템은 없다
- 어떤 시스템에 대해서도 완벽하게 동작하는 시스템 설계란 존재할 수 없다.
- 다르게 설계한 동일한 기능의 시스템은 각자 장단점을 가지고 있다.
- 사례를 잘 이해하고, 문제의 범위를 설정하고, 합리적인 가정을 세운뒤, 명확하게 설계한 시스템을 만드는 것이다.
- 내가 설계한 시스템의 약점을 명확히 이해하고, 열린마음으로 받아들여라.
- 아주 완벽한걸 기대하지 말라