# 05장 비트조작 면접문제

## 시작하기 전에...
자바스크립트 비트 연산 특성:
1. 자바스크립트는 64bit number 자료형을 가지고있음(부동소수 포함)
2. 하지만, number를 비트연산 할 경우 32bit signed integer로 변환해서 연산한뒤 다시 Number형으로 변환함
결론:
JavaScript숫자를 32bit로 가정하고 비트연산 문제를 풀 수 있다.
출처:
https://www.w3schools.com/js/js_bitwise.asp

## 5.1 삽입:
두 개의 32비트 수 N과 M이 주어지고, 비트의 위치 i와 j가 주어졌을 때, M을 N에 삽입하는 메서드를 구현하라.
M은 N의 j번째 비트에서 시작하여 i번째 비트에서 끝난다.
j번째 비트에서 i번째 비트까지에는 M을 담기에 충분한 공간이 있다고 가정한다.
다시말해, M = 10011이라면, j와 i사이에 적어도 다섯비트가 있다고 가정해도 된다는 것이다.
j=3이고 i=2인 경우처럼 M을 삽입할 수 없는 상황은 생기지 않는다고 봐도 된다.

```
입력: N = 10000000000, M = 10011, i = 2, j = 6
출력: N = 10001001100
```
```javascript
function insertSubBits(N, M, i, j) {
    let mask = ~(-1 << (j - i + 1));
    mask = ~(mask << i);

    N = N & mask;

    N = N | (M << i);

    return N;
}
```
해설:
```
1. mask: -1(1s)을 i,j 사이의 길이 만큼 왼쪽 시프트 후 반전
    - 111...1111100000
    - 000...0000011111
2. mask: i만큼 왼쪽 시프트 후 반전
    - 000...0001111100
    - 111...1110000011
3. N과 mask를 AND 연산
    - N에서 mask가 0이었던 부분이 0이됨
    - XXX...XXX00000XX
4. M을 i만큼 왼쪽 시프트 후, M과 OR 연산
    - 000...0001001100
    - XXX...XXX10011XX
```

해답과 비교:
- mask 만드는 방법에서 차이가 있었음
    1. left = ~0 << (j + 1)
        - 111000000
    2. right = (1 << i) - 1
        - 000000011
    3. mask = left | right
        - 111000011
    - 더 직관적임
    - 0이고 뒷부분이 1인 비트를 만드는 더 간단한 방법을 알게됨
## 5.3 비트 뒤집기:
어떤 정수가 주어졋을 때 여러분은 이 정수의 비트 하나를 0에서 1로 바꿀 수 있다.
이때 1이 연속으로 나올 수 있는 가장 긴 길이를 구하는 코드를 작성하라.

```javascript
const BIT_NUM = 32;

function solution(n) {
    let maxSum = 0;
    let prev = null;
    let len = 0;

    for (let i = 0; i < BIT_NUM; i++) {
        const isOne = checkBit(n, i);

        if (isOne) len += 1;
        
        // 체크조건: bit가 0이거나 마지막 이면서, 0이 반복되지 않을 것
        if ((!isOne || i === BIT_NUM - 1) && len !== 0) {
            // prev 초기값 체크
            maxSum = prev === null ? len : Math.max(maxSum, len + prev + 1);
            prev = len;
            len = 0;
        }
    }

    return maxSum;
}

function checkBit(n, i) {
    return (n & (1 << i)) !== 0;
}
```

답안과 비교:
1. 정수 bit를 배열로 바꿔서 처리하는 방법이 있음
    - 숫자: n, 이진수의 자리수: b
    - 시간복잡도: O(b), 공간복잡도: O(b)
2. 최적해답 비교 및 개선점
    - 전부 1일경우(~n === 0)를 체크함
        - 특정조건에서 불필요한 계산 없앰
    - (a === 0)이 될때까지 n을 오른쪽 시프트해서 '(n & 1) === 0' 조건으로 구분함
        - 위는 무조건 비트수(32)만큼 반복하지만, 해답에서는 그렇지 않음

## 5.5 디버거:
다음 코드가 하는 일을 설명하라.
```java
((n & (n - 1)) === 0)
```
1. A & B === 0: A와 B에서 1비트의 위치가 같은곳이 없다는 뜻
```
010010
101101
------
000000

010000
100001
------
000000
```
2. 2진수에서 1을 뺄때 최하위 비트가 1이면 0으로 만들고, 0이면 윗 수에서 빌려오게됨
```
if      n = 1110
if    n-1 = 1101
----------------
if      n = 0001
then  n-1 = 0000
----------------
if      n = 0100
then  n-1 = 0011
```
3. n의 비트중에 하나만 1인경우 참이 성립함.


정답: 숫자가 2의 제곱수인지 구분하는 식(지수가 0인것 포함)

