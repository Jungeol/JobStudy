# 면접문제 08장 재귀와 동적 프로그래밍(짝수)

## 8.2 격자판(grid) 상의 로봇:
행의 개수는 r, 열의 개수는 c인 격자판의 왼쪽 상단 꼭짓점에 로봇이 놓여있다고 상상해보자. 이 로봇은 오른쪽 아니면 아래쪽으로만 이동할 수 있다. 하지만 어떤 셀(cell)은 '금지 구역'으로 지정되어있어서 로봇이 접근할 수 없다. 왼쪽 상단 꼭짓점에서 오른쪽 하단 꼭짓점으로 경로를 찾는 알고리즘을 설계하라.

1. 시간복잡도: O(2**(r+c))
```typescript
class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

function getPath(maze: Boolean[][]): Array<Point> {
    if (maze === null || maze.length === 0) { return null; }
    const path = new Array<Point>();
    if (_getPath(maze, maze.length - 1, maze[0].length - 1, path)) {
        return path;
    }
    return null;
}

function _getPath(maze: Boolean[][], row: number, col: number, path: Array<Point>): Boolean {
    /* 범위를 벗어났거나 지나갈 수 없으면 false를 반환한다 */
    if (col < 0 || row < 0 || !maze[row][col]) {
        return false;
    }

    const isAtOrigin = (row === 0) && (col === 0);

    /* 경로가 존재하면 현재 위치를 더한다. */
    if (isAtOrigin || _getPath(maze, row, col - 1, path) || _getPath(maze, row - 1, col, path)) {
        const p = new Point(row, col);
        path.push(p);
        return true;
    }

    return false;
}
```

2. 시간복잡도: O(rc)
```typescript
namespace MazePath2 {
    class Point {
        x: number;
        y: number;
        constructor(x: number, y: number) {
            this.x = x;
            this.y = y;
        }
    }
    
    function getPath(maze: number[][]): Array<Point> {
        if (maze === null || maze[0].length === 0) return null;
        const path = new Array<Point>();
        const failedPoints = new Map<Point, Boolean>();
        if (_getPath(maze, maze.length - 1, maze[0].length - 1, path, failedPoints)) {
            return path;
        }
        return null;
    }

    function _getPath(maze: number[][], row: number, col: number, path: Array<Point>, failedPoints: Map<Point, Boolean>): Boolean {
        /* 범위를 벗어났거나 지나갈 수 없으면 false를 반환한다 */
        if (col < 0 || row < 0 || !maze[row][col]) {
            return false;
        }

        const p = new Point(row, col);
        
        /* 이미 방문했다면 false를 반환 */
        if (failedPoints.has(p)) {
            return false;
        }

        const isAtOrigin = (row === 0) && (col === 0);

        /* 경로가 존재하면 현재 위치를 더한다. */
        if (isAtOrigin || _getPath(maze, row, col - 1, path, failedPoints) || _getPath(maze, row - 1, col, path, failedPoints)) {
            path.push(p);
            return true;
        }

        failedPoints.set(p, false); // 캐시 결과
        return false;
    }
}
```

## 8.4 부분집합:
어떤 집합의 부분집합을 전부 반환하는 메서드를 작성하라.

1. 각 원소는 부분집합에 속하던지 그렇지 않던지 둘중 하나 
    - 2**n개의 부분집합이 존재
2. 부분집합의 리스트를 반환하는 경우
    - 전체 부분집합의 개수는 2**n
    - 각 원소는 전체 부분집합의 절반(2**(n-1))에는 속하게 된다
3. 공간복잡도가 O(n*2**n)보다 나을 수 없다

해법 1: 재귀(초기사례에서의 확장)
```
초기사례: n = 0
부분집합: {}

초기사례: n = 1
부분집합: {}, {a1}

초기사례: n = 2
부분집합: {}, {a1}, {a2}, {a1, a2}

초기사례: n = 3
부분집합: {}, {a1}, {a2}, {a3}, {a1, a2}, {a1, a3}, {a2, a3}, {a1, a2, a3}
```
```typescript
function getSubsets(set: Array<number>, index: number): Array<Array<number>> {
    let allsubsets: Array<Array<number>> = null;
    if (set.length === index) { //초기사례, 공집합 추가
        allsubsets = new Array<Array<number>>();
        allsubsets.push(new Array<number>());
    } else {
        allsubsets = getSubsets(set, index + 1);
        const item = set[index];
        const moresubsets = new Array<Array<number>>();
        for (let i = 0; i < allsubsets.length; i++) {
            const newsubset = allsubsets[i].slice();
            newsubset.push(item);
            moresubsets.push(newsubset);
        }
        allsubsets = allsubsets.concat(moresubsets);
    }
    return allsubsets;
}
```

해법 2: 조합론(combinatorics)
1. 집합을 생성할 때 원소 각각에 대해 두 가지 중 한 가지를 결정해야 한다.
2. yes, yes, no, yes, no 처럼 표현 가능
3. yes를 1로 no를 0으로 표현한다면, 각 부분집합은 이진 문자열로 표현 할 수 있다.
4. 따라서 1 부터 2**n까지의 모든 정수의 이진 표현을 집합으로 변환하면 된다.

```typescript
function getSubsets2(set: Array<number>): Array<Array<number>> {
    const allsubsets = new Array<Array<number>>();
    const max = 1 << set.length; /* 2^n 계산 */
    for (let n = 0; n < max; n++) {
        allsubsets.push(convertToSet(set, n));
    }
    return allsubsets;
}

function convertToSet(set: Array<number>, num: number): Array<number> {
    const subset = new Array<number>();
    let index = 0;
    for (let k = num; k > 0; k >>= 1) {
        if ((num & 1) === 1) {
            subset.push(set[index])
        }
        index += 1;
    }
    return subset;
}
```

※ 두 해법은 어느쪽이 특별히 더 좋거나 나쁘지 않다.


## 8.6 하노이타워:
전형적인 하노이 타워에서는 크기가 서로 다른 n개의 원반을 세 개의 기둥 중 아무 곳으로나 옮길 수 있다. 초기에 원반은 크기가 맨 위에서부터 아래로 커지는 순서대로 쌓여있다. 그리고 이문제에는 다음과 같은 제약조건이 있다.
1. 원반을 한 번에 하나만 옮길 수 있다
2. 맨 위에 있는 원반 하나를 다른 기둥으로 옮길 수 있다
3. 원반은 자신보다 크기가 작은 디스크 위에 놓을 수 없다
스택을 사용하여 모든 원반을 첫 번째 기둥에서 마지막 기둥으로 옮기는 프로그램을 작성하라.

```
    |               |               |
    -               |               |
   ---              |               |
  -----             |               |
 -------            |               |
---------           |               |
```
초기 사례로부터의 확장법을 사용하기 좋은 예
```
n = 1
원판1을 기둥 1에서 기둥3으로 옮길 수 있나? O
1. 원판1: 1 -> 3

n = 2
원판1, 2를 기둥 1에서 기둥3으로 옮길 수 있나? O
1. 원판1: 1 -> 2
2. 원판2: 1 -> 3
3. 원판1: 1 -> 3

n = 3
원판1, 2, 3을 기둥 1에서 기둥3으로 옮길 수 있나? O
1. (원판 1,2를 기둥2로 옮김)
2. 원판3: 1 -> 3
3. (원판 1,2를 기둥3으로 옮김)

n = 4
원판 1, 2, 3, 4를 기둥 1에서 기둥3으로 옮길 수 있나? O
1. (원판 1,2,3을 기둥2로 옮김)
2. 원판4: 1 -> 3
3. (원판 1,2,3을 기둥3으로 옮김)
```
의사코드
```java
moveDisks(int n, Tower origin, Tower destination, Tower buffer) {
    /* 초기사례 */
    if (n <= 0) return;

    /* destination을 버퍼로 사용하여 
    맨 위 n-1개의 원판을 origin에서 buffer로 옮긴다 */
    moveDisks(n - 1, origin, buffer, destination);
    
    /* 가장 윗 원판을 origin에서 destination으로 옮긴다 */
    moveTop(origin, destination);

    /* origin을 버퍼로 사용하여 
    맨 위 n-1개의 원판을 buffer에서 destination으로 옮긴다 */
    moveDisks(n - 1, buffer, origin, destination);
}
```

실제 코드

```typescript
class Tower {
    private disks: Array<number>;
    private index: number;
    constructor(i: number) {
        this.disks = new Array<number>();
        this.index = i;
    }

    public getIndex(): number {
        return this.index;
    }
    public add(d: number): void {
        if (this.disks.length !== 0 
          && this.disks[this.disks.length - 1] <= d) {
            console.log("Error placing disk " + d)
        } else {
            this.disks.push(d);
        }
    }
    public moveTopTo(t: Tower): void {
        const top = this.disks.pop();
        t.add(top);
    }
    public moveDisks(n: number, dest: Tower, buffer: Tower): void {
        if (n > 0) {
            this.moveDisks(n - 1, buffer, dest);
            this.moveTopTo(dest);
            buffer.moveDisks(n - 1, dest, this);
        }
    }
}

function main() {
    const n = 4;
    const towers = new Tower[3];
    for (let i = 0; i < 3; i++) {
        towers[i] = new Tower(i);
    }

    for (let i = n - 1; i >= 0; i--) {
        towers[0].add(i);
    }
    towers[0].moveDisk(n, towers[2], towers[1]);
}

main();
```

## 8.8 중복있는 순열:
문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 문자는 중복되어 나타날 수 있지만, 나열된 순열은 서로 중복되면 안 된다.

## 8.10 영역 칠하기:
이미지 편집 프로그램에서 흔히 쓰이는 '영역 칠하기'함수를 구현하라. 영역 칠하기 함수는 화면(색이 칠해진 이차원 배열)과 그 화면상의 한 지점, 그리고 새로운 색상이 주여졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 색칠한다.

## 8.12 여덟 개의 퀸:
8x8 체스판 위에 여덟 개의 퀸이 서로 잡아먹히지 않도록 놓을 수 있는 모든 가능한 방법을 출력하는 알고리즘을 작성하라. 즉, 퀸은 서로 같은 행, 열, 대각선상에 놓이면 안된다. 여기서 '대각선'은 모든 대각선을 의미하는 것으로, 체스판을 양분하는 대각선 두 개로 한정하지 않는다.

## 8.14 불린 값 계산:
0, 1, &, |, ^으로 구성된 불린 표현식과, 원하는 계산결과(역시 불린값)가 주여 졌을때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 개수를 출력하는 함수를 구현하라.