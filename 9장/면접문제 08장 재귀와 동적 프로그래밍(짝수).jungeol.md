# 면접문제 08장 재귀와 동적 프로그래밍(짝수)

## 8.2 격자판(grid) 상의 로봇:
행의 개수는 r, 열의 개수는 c인 격자판의 왼쪽 상단 꼭짓점에 로봇이 놓여있다고 상상해보자. 이 로봇은 오른쪽 아니면 아래쪽으로만 이동할 수 있다. 하지만 어떤 셀(cell)은 '금지 구역'으로 지정되어있어서 로봇이 접근할 수 없다. 왼쪽 상단 꼭짓점에서 오른쪽 하단 꼭짓점으로 경로를 찾는 알고리즘을 설계하라.

1. 시간복잡도: O(2**(r+c))
```typescript
class Point {
    x: number;
    y: number;
    constructor(x: number, y: number) {
        this.x = x;
        this.y = y;
    }
}

function getPath(maze: Boolean[][]): Array<Point> {
    if (maze === null || maze.length === 0) { return null; }
    const path = new Array<Point>();
    if (_getPath(maze, maze.length - 1, maze[0].length - 1, path)) {
        return path;
    }
    return null;
}

function _getPath(maze: Boolean[][], row: number, col: number, path: Array<Point>): Boolean {
    /* 범위를 벗어났거나 지나갈 수 없으면 false를 반환한다 */
    if (col < 0 || row < 0 || !maze[row][col]) {
        return false;
    }

    const isAtOrigin = (row === 0) && (col === 0);

    /* 경로가 존재하면 현재 위치를 더한다. */
    if (isAtOrigin || _getPath(maze, row, col - 1, path) || _getPath(maze, row - 1, col, path)) {
        const p = new Point(row, col);
        path.push(p);
        return true;
    }

    return false;
}
```

2. 시간복잡도: O(rc)
```typescript
namespace MazePath2 {
    class Point {
        x: number;
        y: number;
        constructor(x: number, y: number) {
            this.x = x;
            this.y = y;
        }
    }
    
    function getPath(maze: number[][]): Array<Point> {
        if (maze === null || maze[0].length === 0) return null;
        const path = new Array<Point>();
        const failedPoints = new Map<Point, Boolean>();
        if (_getPath(maze, maze.length - 1, maze[0].length - 1, path, failedPoints)) {
            return path;
        }
        return null;
    }

    function _getPath(maze: number[][], row: number, col: number, path: Array<Point>, failedPoints: Map<Point, Boolean>): Boolean {
        /* 범위를 벗어났거나 지나갈 수 없으면 false를 반환한다 */
        if (col < 0 || row < 0 || !maze[row][col]) {
            return false;
        }

        const p = new Point(row, col);
        
        /* 이미 방문했다면 false를 반환 */
        if (failedPoints.has(p)) {
            return false;
        }

        const isAtOrigin = (row === 0) && (col === 0);

        /* 경로가 존재하면 현재 위치를 더한다. */
        if (isAtOrigin || _getPath(maze, row, col - 1, path, failedPoints) || _getPath(maze, row - 1, col, path, failedPoints)) {
            path.push(p);
            return true;
        }

        failedPoints.set(p, false); // 캐시 결과
        return false;
    }
}
```

## 8.4 부분집합:
어떤 집합의 부분집합을 전부 반환하는 메서드를 작성하라.

## 8.6 하노이타워:
전형적인 하노이 타워에서는 크기가 서로 다른 n개의 원반을 세 개의 기둥 중 아무 곳으로나 옮길 수 있다. 초기에 원반은 크기가 맨 위에서부터 아래로 커지는 순서대로 쌓여있다. 그리고 이문제에는 다음과 같은 제약조건이 있다.
1. 원반을 한 번에 하나만 옮길 수 있다
2. 맨 위에 있는 원반 하나를 다른 기둥으로 옮길 수 있다
3. 원반은 자신보다 크기가 작은 디스크 위에 놓을 수 없다
스택을 사용하여 모든 원반을 첫 번째 기둥에서 마지막 기둥으로 옮기는 프로그램을 작성하라.

## 8.8 중복있는 순열:
문자열이 주어졌을 때 모든 경우의 순열을 계산하는 메서드를 작성하라. 문자는 중복되어 나타날 수 있지만, 나열된 순열은 서로 중복되면 안 된다.

## 8.10 영역 칠하기:
이미지 편집 프로그램에서 흔히 쓰이는 '영역 칠하기'함수를 구현하라. 영역 칠하기 함수는 화면(색이 칠해진 이차원 배열)과 그 화면상의 한 지점, 그리고 새로운 색상이 주여졌을 때, 주어진 지점과 색이 같은 주변 영역을 새로운 색상으로 다시 색칠한다.

## 8.12 여덟 개의 퀸:
8x8 체스판 위에 여덟 개의 퀸이 서로 잡아먹히지 않도록 놓을 수 있는 모든 가능한 방법을 출력하는 알고리즘을 작성하라. 즉, 퀸은 서로 같은 행, 열, 대각선상에 놓이면 안된다. 여기서 '대각선'은 모든 대각선을 의미하는 것으로, 체스판을 양분하는 대각선 두 개로 한정하지 않는다.

## 8.14 불린 값 계산:
0, 1, &, |, ^으로 구성된 불린 표현식과, 원하는 계산결과(역시 불린값)가 주여 졌을때, 표현식에 괄호를 적절하게 추가하여 그 값이 원하는 결과값과 같게 만들 수 있는 모든 경우의 개수를 출력하는 함수를 구현하라.